@@ -1,56 +1,64 @@
 module Parser (parse) where


 import qualified Text.Megaparsec as M
 import Text.Megaparsec.Char (char)
 import Data.Void
 import RegEx

 type MParser = M.Parsec Void String
 data MatchingType = Pos | Neg deriving (Eq)

 notChar :: Char -> MParser Char
 notChar c = M.satisfy (/=c)

 anyNotUsed :: String -> MParser Char
 anyNotUsed s = M.satisfy $ not . (`elem` s)

 -- The regex parser starts here
 -- https://github.com/kean/Regex/blob/master/grammar.ebnf
 -- I had to adjust the rule CharacterGroup
 -- CharacterGroup         ::= PositiveCharacterGroup | NegativeCharacterGroup
 -- PositiveCharacterGroup ::= "[" CharacterGroupItem+ "]"
 -- CharacterGroup         ::= "[" CharacterGroupNegativeModifier CharacterGroupItem+ "]"

 pRegEx :: MParser (M Char)
-pRegEx = pExpression
+pRegEx = do
+  s <- pStartOfString
+  e <- pExpression
+  return $ concatM [s, e]
+
+pStartOfString :: MParser (M Char)
+pStartOfString = do
+  s <- M.optional $ char '^'
+  return $ case s of
+    Nothing -> concatM [kleeneStarM anyCharM]
+    Just _ -> noOpM

 pExpression :: MParser (M Char)
-pExpression = do
-  ex <- pSubExpression
-  return $ concatM [kleeneStarM anyCharM, ex, kleeneStarM anyCharM]
+pExpression = pSubExpression

 pSubExpression :: MParser (M Char)
 pSubExpression = do
   subExp <- M.some $ M.try pMatch
   return $ concatM subExp

 pMatch :: MParser (M Char)
 pMatch = pMatchItem

 pMatchItem :: MParser (M Char)
 pMatchItem = do
   M.try pMatchCharacterClass M.<|> M.try pMatchCharacter

 pMatchCharacterClass :: MParser (M Char)
 pMatchCharacterClass = M.try pCharacterGroup M.<|> fmap (\g -> g Pos ) (M.try pCharacterClass)

 pMatchCharacter :: MParser (M Char)
 pMatchCharacter = do
   c <- anyNotUsed "|()$"
   return $ posLit c

 pCharacterGroup :: MParser (M Char)
 pCharacterGroup = M.try pPositiveCharacterGroup M.<|> M.try pNegativeCharacterGroup

 pPositiveCharacterGroup :: MParser (M Char)
