In this stage we do not have to learn any new concepts.
We only create an additional if statement and create the `getNotAllowedCharacters` which is basically the opposite of the `getAllowedCharacters` function from the previous stage.

You may notice that the many nested if statements make it difficult to read and write code.
Also, up to this point the code is written in a more or less imperative style like you may be most familiar with from your current experience with other languages.
However, one of the key reasons for using Haskell is its support for programming in the functional style.

Although it was a good exercise to get familiar with the challenge and the Haskell programming language till now, progressing further along this path will result in code that is much more complicated later. We will therefore rewrite everything that we have done till now in the next stage in order to get the full benefits of programming in the functional style in Haskell.


In the next stage we will learn about:
- `type`, `newtype` and `data` keywords - [Haskell Wiki - Type](https://wiki.haskell.org/Type)
- Recursion as a key concept in Haskell - [Recursion](http://learnyouahaskell.com/recursion)
- Currying - [Haskell Wiki - Currying](https://wiki.haskell.org/Currying)
- How to build functions from smaller functions
- Functors, Applicative Functors and Monads - [Monads and other Functional Structures](https://mmhaskell.com/monads)
- How to write a proper parser for RegEx in Haskell - [Parser Combinators in Haskell](https://serokell.io/blog/parser-combinators-in-haskell)
- any many more

This pill will be bit of a hard one to swallow, but you will learn a lot about functional programming in general.
Fortunately, extending your application is going to be a lot easier after the next stage.
