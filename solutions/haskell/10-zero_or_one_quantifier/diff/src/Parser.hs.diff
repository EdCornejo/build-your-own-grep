@@ -40,51 +40,53 @@
 pEndOfString = do
   s <- M.optional $ char '$'
   return $ case s of
     Nothing -> concatM [kleeneStarM anyCharM]
     Just _ -> emptyStrM

 pExpression :: MParser (M Char)
 pExpression = pSubExpression

 pSubExpression :: MParser (M Char)
 pSubExpression = do
   subExp <- M.some $ M.try pMatch
   return $ concatM subExp

 pMatch :: MParser (M Char)
 pMatch = do
   i <- pMatchItem
   q <- M.optional pQuantifiers
   return $ case q of
           Nothing -> i
           Just c -> quantifier c i

 quantifier :: Char -> M Char -> M Char
 quantifier c i =
   case c of
+    '*' -> kleeneStarM i
     '+' -> kleenePlusM i
+    '?' -> altM [noOpM, i]
     _   -> error "Invalid quantifier"

 pMatchItem :: MParser (M Char)
 pMatchItem = do
   M.try pMatchCharacterClass M.<|> M.try pMatchCharacter

 pMatchCharacterClass :: MParser (M Char)
 pMatchCharacterClass = M.try pCharacterGroup M.<|> fmap (\g -> g Pos ) (M.try pCharacterClass)

 pMatchCharacter :: MParser (M Char)
 pMatchCharacter = do
   -- TODO: Update to only consume non special characters like letters or digits etc.
   c <- anyNotUsed "|()$"
   return $ posLit c

 pCharacterGroup :: MParser (M Char)
 pCharacterGroup = M.try pPositiveCharacterGroup M.<|> M.try pNegativeCharacterGroup

 pPositiveCharacterGroup :: MParser (M Char)
 pPositiveCharacterGroup = do
   _ <- char '['
   c <- anyNotUsed "^]"
   cs <- M.many $ pCharacterGroupItem posLit Pos
   let cs' = posLit c : cs
   _ <- char ']'
@@ -100,34 +102,40 @@

 pCharacterGroupItem :: (Char -> M Char) -> MathingType -> MParser (M Char)
 pCharacterGroupItem f b = fmap (\g -> g b) (M.try pCharacterClass) M.<|> fmap f (M.try pChar)


 pCharacterClass :: MParser (MathingType -> M Char)
 pCharacterClass = M.try pCharacterClassAnyWord M.<|> M.try pCharacterClassAnyDecimal

 pCharacterClassAnyWord :: MParser (MathingType -> M Char)
 pCharacterClassAnyWord = do
   _ <- char '\\'
   _ <- char 'w'
   return $ \b -> if b == Pos then alphaNumM else alphaNumInverseM


 pCharacterClassAnyDecimal :: MParser (MathingType -> M Char)
 pCharacterClassAnyDecimal = do
   _ <- char '\\'
   _ <- char 'd'
   return $ \b -> if b == Pos then digitM else digitInverseM

 pChar :: MParser Char
 pChar = notChar ']'

 pQuantifiers :: MParser Char
-pQuantifiers = M.try oneOrMoreQuantifier
+pQuantifiers = M.try zeroOrMoreQuantifier M.<|> M.try oneOrMoreQuantifier M.<|> M.try zeroOrOneQuantifier
+
+zeroOrMoreQuantifier :: MParser Char
+zeroOrMoreQuantifier = char '*'

 oneOrMoreQuantifier :: MParser Char
 oneOrMoreQuantifier = char '+'

+zeroOrOneQuantifier :: MParser Char
+zeroOrOneQuantifier = char '?'
+
 parse :: String -> M Char
 parse s = case M.parse pRegEx "Error" s of
                  Left e -> error $ M.errorBundlePretty e
                  Right x -> x
