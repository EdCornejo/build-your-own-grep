@@ -1,46 +1,46 @@
-module Main where
+module Main (main) where

-import Data.Char
-import Data.List
-import Data.Maybe
+import System.IO
 import System.Environment
 import System.Exit
+import Data.Maybe
+import Parser
+import RegEx

-getAllowedCharacters :: String -> String
-getAllowedCharacters s = take (length s - 2) $ tail s
+match :: M Char -> String -> Bool
+match pat s = isMatching pat s

-getNotAllowedCharacters :: String -> String
-getNotAllowedCharacters s = take (length s - 3) $ tail $ tail s
+grep :: M Char -> IO [(Bool, String)]
+grep pat = do
+  done <- isEOF
+  if done
+    then return $ []
+    else do
+      input_line <- getLine
+      let r = match pat input_line
+      rs <- grep pat
+      return $ (r, input_line) : rs

-matchPattern :: String -> String -> Bool
-matchPattern pat input = do
-  if pat == "\\d"
-    then any isDigit input
-    else
-      if pat == "\\w"
-        then any (\c -> isAlphaNum c || c == '_') input
-        else
-          if take 2 pat == "[^"
-            then not $ or $ fmap (`elem` input) (getNotAllowedCharacters pat)
-            else
-              if head pat == '['
-                then or $ fmap (`elem` input) (getAllowedCharacters pat)
-                else
-                  if length pat == 1
-                    then head pat `elem` input
-                    else error $ "Unhandled pattern: " ++ pat

 main :: IO ()
 main = do
   args <- getArgs
-  let pat = args !! 1
-  input_line <- getLine
+  let pat = parse $ unwords $ tail args

-  if head args /= "-E"
+  if isNothing pat
     then do
-      putStrLn "Expected first argument to be '-E'"
+      putStrLn "Invalid pattern"
       exitFailure
-    else
-      if matchPattern pat input_line
-        then exitSuccess
-        else exitFailure
+    else do
+      if head args /= "-E"
+      then do
+        putStrLn "Expected first argument to be '-E'"
+        exitFailure
+      else do
+        bs <- grep $ astToMatcher $ fromJust pat
+        if any ((==True) . fst) bs
+          then do
+            mapM_ (putStrLn . snd) $ filter ((==True) . fst) bs
+            exitSuccess
+          else do
+            exitFailure
