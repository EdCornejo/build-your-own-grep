@@ -30,51 +30,62 @@
   return $ concatM [s, ex, e]

 pStartOfString :: MParser (M Char)
 pStartOfString = do
   s <- M.optional $ char '^'
   return $ case s of
     Nothing -> concatM [kleeneStarM anyCharM]
     Just _ -> noOpM

 pEndOfString :: MParser (M Char)
 pEndOfString = do
   s <- M.optional $ char '$'
   return $ case s of
     Nothing -> concatM [kleeneStarM anyCharM]
     Just _ -> emptyStrM

 pExpression :: MParser (M Char)
 pExpression = pSubExpression

 pSubExpression :: MParser (M Char)
 pSubExpression = do
   subExp <- M.some $ M.try pMatch
   return $ concatM subExp

 pMatch :: MParser (M Char)
-pMatch = pMatchItem
+pMatch = do
+  i <- pMatchItem
+  q <- M.optional pQuantifiers
+  return $ case q of
+          Nothing -> i
+          Just c -> quantifier c i
+
+quantifier :: Char -> M Char -> M Char
+quantifier c i =
+  case c of
+    '+' -> kleenePlusM i
+    _   -> error "Invalid quantifier"

 pMatchItem :: MParser (M Char)
 pMatchItem = do
   M.try pMatchCharacterClass M.<|> M.try pMatchCharacter

 pMatchCharacterClass :: MParser (M Char)
 pMatchCharacterClass = M.try pCharacterGroup M.<|> fmap (\g -> g Pos ) (M.try pCharacterClass)

 pMatchCharacter :: MParser (M Char)
 pMatchCharacter = do
   -- TODO: Update to only consume non special characters like letters or digits etc.
   c <- anyNotUsed "|()$"
   return $ posLit c

 pCharacterGroup :: MParser (M Char)
 pCharacterGroup = M.try pPositiveCharacterGroup M.<|> M.try pNegativeCharacterGroup

 pPositiveCharacterGroup :: MParser (M Char)
 pPositiveCharacterGroup = do
   _ <- char '['
   c <- anyNotUsed "^]"
   cs <- M.many $ pCharacterGroupItem posLit Pos
   let cs' = posLit c : cs
   _ <- char ']'
   return $ altM cs'
@@ -88,29 +99,35 @@
   return $ andM ms

 pCharacterGroupItem :: (Char -> M Char) -> MathingType -> MParser (M Char)
 pCharacterGroupItem f b = fmap (\g -> g b) (M.try pCharacterClass) M.<|> fmap f (M.try pChar)


 pCharacterClass :: MParser (MathingType -> M Char)
 pCharacterClass = M.try pCharacterClassAnyWord M.<|> M.try pCharacterClassAnyDecimal

 pCharacterClassAnyWord :: MParser (MathingType -> M Char)
 pCharacterClassAnyWord = do
   _ <- char '\\'
   _ <- char 'w'
   return $ \b -> if b == Pos then alphaNumM else alphaNumInverseM


 pCharacterClassAnyDecimal :: MParser (MathingType -> M Char)
 pCharacterClassAnyDecimal = do
   _ <- char '\\'
   _ <- char 'd'
   return $ \b -> if b == Pos then digitM else digitInverseM

 pChar :: MParser Char
 pChar = notChar ']'

+pQuantifiers :: MParser Char
+pQuantifiers = M.try oneOrMoreQuantifier
+
+oneOrMoreQuantifier :: MParser Char
+oneOrMoreQuantifier = char '+'
+
 parse :: String -> M Char
 parse s = case M.parse pRegEx "Error" s of
                  Left e -> error $ M.errorBundlePretty e
                  Right x -> x
