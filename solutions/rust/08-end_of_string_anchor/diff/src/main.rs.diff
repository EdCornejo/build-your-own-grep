@@ -1,50 +1,52 @@
 use std::env;
 use std::io;
 use std::process;

 fn match_pattern(input_line: &str, pattern: &str) -> bool {
     if pattern.starts_with("^") {
         // Match at the start of the input only, don't search later in the input string
         return match_pattern_occurrence(input_line, &pattern[1..]);
     }

     let mut chars_iter = input_line.chars();
     loop {
         if match_pattern_occurrence(chars_iter.as_str(), pattern) {
             return true;
         }

         if chars_iter.next().is_none() {
             return false;
         }
     }
 }

 fn match_pattern_occurrence(input: &str, pattern: &str) -> bool {
     if pattern.is_empty() {
         true
+    } else if pattern == "$" {
+        input.len() == 0
     } else if input.is_empty() {
         false
     } else if pattern.starts_with(r"\d") {
         match input.chars().next() {
             Some('0'..='9') => match_pattern_occurrence(&input[1..], &pattern[2..]),
             _ => false,
         }
     } else if pattern.starts_with(r"\w") {
         match input.chars().next() {
             Some('0'..='9' | 'a'..='z' | 'A'..='Z' | '_') => {
                 match_pattern_occurrence(&input[1..], &pattern[2..])
             }
             _ => false,
         }
     } else if pattern.starts_with("[^") {
         let end_index = if let Some(i) = pattern.find("]") {
             i
         } else {
             panic!("Unclosed '[' in pattern");
         };

         let current_input_char = input.chars().next().unwrap();
         for ch in pattern.chars().skip(2).take(end_index - 2) {
             if ch == current_input_char {
                 return false;
